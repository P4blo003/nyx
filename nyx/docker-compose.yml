# ==========================================================================================
# Author: Pablo González García.
# Created: 31/12/2025
# Last edited: 02/02/2026
#
# Docker Compose file for deploying multiple Triton Inference Server instances.
#
# This setup separates inference workloads by nature:
# - Triton + vLLM for Large Language Models (LLMs).
# - Triton + ONNX Runtime for classical ML / DL models.
#
# The separation allows independent optimization, scaling and deployment.
# ==========================================================================================


# ==============================
# NETWORKS
# ==============================

networks:
  # Shared network for inter-service communication between core application services.
  common-net:
    driver: bridge
  # Internal bridge network used for communication between Triton containers
  # and any auxiliary services (API gateways, orchestrators, etc).
  # This network is not intended to be exposed externally.
  triton-net:
    driver: bridge
  # Network dedicated to metrics, monitoring and observability components.
  metrics-net:
    driver: bridge
  
  cache-net:
    driver: bridge


# ==============================
# SERVICES
# ==============================

services:

  dcgm-exporter:
    build:
      context: ./third-party/dcgm-exporter
      dockerfile: Dockerfile
    
    container_name: dcgm-exporter

    environment:
      - DCGM_EXPORTER_INTERVAL=1000

    networks:
      - metrics-net

    ports:
      - "9400:9400"

    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]

  prometheus:
    build:
      context: ./third-party/prometheus
      dockerfile: Dockerfile
    container_name: prometheus

    environment:
      - name=value

    restart: unless-stopped

    networks:
      - metrics-net

    volumes:
      - ./third-party/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - ./third-party/prometheus/data:/prometheus

    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=6h'
      - '--web.enable-lifecycle'
  
  grafana:
    build:
      context: ./third-party/grafana
      dockerfile: Dockerfile
    container_name: grafana

    restart: unless-stopped

    environment:
      - GF_SECURITY_ADMIN_USER=${GF_SECURITY_ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GF_SECURITY_ADMIN_PASSWORD}
      - GF_DASHBOARDS_MIN_REFRESH_INTERVAL=1s

    networks:
      - metrics-net

    ports:
      - "3000:3000"

    volumes:
      - ./third-party/grafana/provisioning:/etc/grafana/provisioning
      - ./third-party/grafana/data:/var/lib/grafana
  
  # Qdrant vector database service.
  # Used for storing and querying embeddings for semantic search and RAG workflow.
  qdrant:
    build:
      context: ./third-party/qdrant
      dockerfile: Dockerfile
    # Explicit container name for easier management and monitoring.
    container_name: qdrant
    # Automatically restart the container unless it is explicitly stopped.
    restart: unless-stopped

    # Environment variables for service configuration.
    environment:
      # API key used to authenticate client requests.
      - QDRANT__SERVICE__API_KEY=${QDRANT_API_KEY}
      # Enable or disable TLS support (true / false).
      - QDRANT__SERVICE__ENABLE_TLS=${QDRANT_ENABLE_TLS}

    # Attach the service to the shared internal networks.
    networks:
      - common-net

    # Expose HTTP and gRPC ports to the host.
    ports:
      # 6333: REST / HTTP API.
      - "6333:6333"
      # 6334: gRPC API.
      - "6334:6334"

    # Persistent storage and configuration.
    volumes:
      # Persistent data directory for collections, indexes and WAL.
      - ./third-party/qdrant/data:/qdrant/storage
      #    Production configuration file (read-only).
      - ./third-party/qdrant/config/production.yaml:/qdrant/config/production.yaml:ro

    # Health check to ensure the service is alive and responsive.
    # Uses the built-in Qdrant healthcheck endpoint.
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/health"]
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 20s

    # Resource limits to prevent the service from exhausting host resources.
    deploy:
      resources:
        limits:
          cpus: "2"
          memory: 4g

  # Triton Inference Server for embedding and classification models.
  triton-onnx:

    # Build image for this service using Dockerfile.
    build:
      context: ./third-party/triton/onnx
      dockerfile: Dockerfile
    # Explicit container name for easier management and monitoring.
    container_name: triton-onnx
    # Enable NVIDIA Container runtime for GPU access.
    runtime: nvidia
    # Automatically restart the container unless it is explicitly stopped.
    restart: unless-stopped

    # Increase shared memory size inside the container.
    # Triton, CUDA, TensorRt, ONNX Runtime and vLLM rely heavily on /dev/shm.
    # For inter-process communication, tensor exchange and dynamic batching.
    # The default Docker value (64 MB) is insufficient for ML inference workloads.
    shm_size: '4gb'
    ulimits:
      # Allows the container to lock unlimited amounts of memory.
      # This is required by CUDA and TensorRT to pin memory and prevent it
      # from being swapped out by the OS.
      memlock: -1
      # Increase the maximum stack size per thread to 64 MB.
      # Deep C++ call stacks used by Triton, TensorRT and ONNX Runtime
      # can overflow the default Linux stack limit (usually 8MB).
      stack: 67108864

    # Environment variables specific to the ONNX workload.
    environment:
      # GPU device(s) visible to this container.
      # When sharing a GPU with vLLM, ONNX models should be lightweight
      # and carefully tuned to avoid attention.
      - CUDA_VISIBLE_DEVICES=0
    
    # Attach the container to the shared internal networks.
    networks:
      - triton-net
      - metrics-net

    # Persistent storage and configuration.
    volumes:
      # Mount the model repository for ONNX-backend models.
      - ./model_repository/onnx:/models:ro
    
    # Start Triton with explicit runtime options.
    # Metrics are enabled for observability and capacity planning.
    command: >
      tritonserver
      --model-repository=/models
      --model-control-mode=explicit
      --log-info=true
      --allow-metrics=true
      --allow-gpu-metrics=true
    
    # Health check to ensure the Triton server is fully ready
    # before traffic is sent to this service.
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/v2/health/ready"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 120s

  # Triton server dedicated to LLM inference using vLLM.
  # This service is expected to run on a GPU with sufficient memory and compute
  # capability to host Large Language Models efficiently.
  triton-vllm:

    # Build image for this service using Dockerfile.
    build:
      context: ./third-party/triton/vllm
      dockerfile: Dockerfile
    # Explicit container name for easier management and monitoring.
    container_name: triton-vllm
    # Enable NVIDIA Container runtime for GPU access.
    runtime: nvidia
    # Automatically restart the container unless it is explicitly stopped.
    restart: unless-stopped

    # Increase shared memory size inside the container.
    # Triton, CUDA, TensorRt, ONNX Runtime and vLLM rely heavily on /dev/shm.
    # For inter-process communication, tensor exchange and dynamic batching.
    # The default Docker value (64 MB) is insufficient for ML inference workloads.
    shm_size: '8gb'
    ulimits:
      # Allows the container to lock unlimited amounts of memory.
      # This is required by CUDA and TensorRT to pin memory and prevent it
      # from being swapped out by the OS.
      memlock: -1
      # Increase the maximum stack size per thread to 64 MB.
      # Deep C++ call stacks used by Triton, TensorRT and ONNX Runtime
      # can overflow the default Linux stack limit (usually 8MB).
      stack: 67108864
    
    # Environment variables specific to the vLLM workload.
    # See https://docs.vllm.ai/en/latest/configuration/env_vars/ for details.
    environment:
      # GPU device(s) visible to this container.
      # Typically a single, dedicated GPU is assigned to the LLM service.
      - CUDA_VISIBLE_DEVICES=0
      # Attention backend used by vLLM.
      # XFORMERS is broadly compatible and stable across GPU generations.
      - VLLM_ATTENTION_BACKEND=XFORMERS

    # Attach the container to the internal networks.
    networks:
      - triton-net
      - metrics-net

    # Mount the model repository for vLLM-backend models.
    volumes:
      - ./model_repository/vllm:/models:ro

    # Start Triton with explicit runtime options.
    # Metrics are enabled for observability and capacity planning.
    command: >
      tritonserver
      --model-repository=/models
      --model-control-mode=explicit
      --log-info=true
      --allow-metrics=true
      --allow-gpu-metrics=true

    # Health check to ensure the Triton server is fully ready
    # before traffic is sent to this service.
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/v2/health/ready"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 120s

  ai-service:
    build:
      context: ./services/ai-service
      dockerfile: Dockerfile
    # Explicit container name for easier management and monitoring.
    container_name: ai-service
    # Automatically restart the container unless it is explicitly stopped.
    restart: unless-stopped

    networks:
      - common-net
      - triton-net
      - metrics-net

    ports:
      # Expose the AI-Service API.
      - "${AI_SERVICE_GRPC_PORT}:8002"

    volumes:
      # Mount development directories.
      - ./services/ai-service/logs:/app/logs
      - ./services/ai-service/src:/app/src
      # Mount the application configuration directory (read-only).
      - ./services/ai-service/config:/app/config:ro

    command: >
      python src/main.py

    healthcheck:
      test: ["CMD", "grpc_health_probe", "-addr=:8002"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s